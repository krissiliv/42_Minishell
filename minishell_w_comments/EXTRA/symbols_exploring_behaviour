ls > out                        prints output of ls to/and creates "out"
wc -l < _testfile               prints the number of newline chars (-1) in _testfile

    => if we have "-" then the following is an option

wc -l > out < _testfile
is the same as 
wc -l < _testfile > out         takes input _testfile and prints result to out
    

    => if we have < in front of a file, then we need to open the file and change
       the fd of stdin (0) to be the fd of the opened file!
       if we have > in front of a file, then we need to open the file and change 
       the fd of stout (1) to be the fd of the opened file!
       stdin:  File descriptor 0
       stdout: File descriptor 1
       stderr: File descriptor 2
            ----> can do that with dup2(int oldfd, int newfd);

____________________output redirection with >>_________________________
◦ >> should redirect output in append mode. (So redirect the output to the file but do not overwrite file content. Instead, just append output to end of the file)


if we have a pipe, then we need to use pipex(int *pipe_ends, char **argv, char **envv, t_pipex_m *pipex_m)
    => can use current main as "pipex_interpreter"
       and say pipex_interpreter(node 1, node 2) of list where node = [cmd, option, argument]
       which pipes the output of the node 1 command to the node 2 command

____________________quotes_____________________________________________
echo "here $?"                  prints "here 0"
echo "here $?                   opens the dquote stuff

        => if we have two "" we should prevent the shell from interpreting the characters in the quoted sequence except for $
            if we have two '' however, the quoted sequence shoould not be interpreted at all (not even $).
           we should Not interpret unclosed quotes (one quote)
        or special characters which are not required by the subject such as \ (backslash) or ; (semicolon).

____________________heredocs____________________________________________
◦ << should be given a delimiter, then read the input until a line containing the delimiter is seen. However, it doesn’t have to update the history!


wc -l _testfile                 prints "1 _testfile" = number of linebreaks in _testfile followed by the name of the argument file
< input_parser.c wc -l          prints "1" so just the number of linebreaks in _testfile

cat _testfile 
is the same as 
< _testfile cat                 prints the content of _testfile


grep "kh" _testfile
is the same as
< _testfile grep "kh"


            ===> so basically we have a command, and an option
                    if we have sth else afterwards it will be the filename (argument)
                    if we have < and sth else or > and sth else eigther before or afterwards, if will be the infile or outfile resp.


____________________missing still: $ stuff___________________________________